<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Aggregate :: Red Hat build of Apache Camel</title>
    <meta name="description" content="Aggregates many messages into a single message">
    <meta name="generator" content="Antora 3.1.4">
    <link rel="stylesheet" href="../../../_/css/site.css">
  </head>
  <body class="article">
<header class="header">
  <nav class="navbar">
    <div class="navbar-brand">
      <a class="navbar-item" href="/">Red Hat build of Apache Camel</a>
      <button class="navbar-burger" data-target="topbar-nav">
        <span></span>
        <span></span>
        <span></span>
      </button>
    </div>
  </nav>
</header>
<div class="body">
<div class="nav-container" data-component="components" data-version="4.0.x">
  <aside class="nav">
    <div class="panels">
<div class="nav-panel-menu is-active" data-panel="menu">
  <nav class="nav-menu">
    <button class="nav-menu-toggle" aria-label="Toggle expand/collapse all" style="display: none"></button>
    <h3 class="title"><a href="../index.html">Camel Components</a></h3>
<ul class="nav-list">
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="enterprise-integration-patterns.html">Enterprise Integration Patterns</a>
<ul class="nav-list">
  <li class="nav-item is-current-page" data-depth="2">
    <a class="nav-link" href="aggregate-eip.html">Aggregate</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="bean-eip.html">Bean</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="change-data-capture.html">Change Data Capture</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="channel-adapter.html">Channel Adapter</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="choice-eip.html">Content Based Router</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="circuitBreaker-eip.html">Circuit Breaker</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="claimCheck-eip.html">Claim Check</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="competing-consumers.html">Competing Consumers</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="composed-message-processor.html">Composed Message Processor</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="content-enricher.html">Content Enricher</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="content-filter-eip.html">Content Filter</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="convertBodyTo-eip.html">Convert Body To</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="correlation-identifier.html">Correlation Identifier</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="dead-letter-channel.html">Dead Letter Channel</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="delay-eip.html">Delay</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="durable-subscriber.html">Durable Subscriber</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="dynamicRouter-eip.html">Dynamic Router</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="enrich-eip.html">Enrich</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="eventDrivenConsumer-eip.html">Event Driven Consumer</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="event-message.html">Event Message</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="filter-eip.html">Filter</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="from-eip.html">From</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="guaranteed-delivery.html">Guaranteed Delivery</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="idempotentConsumer-eip.html">Idempotent Consumer</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="intercept.html">Intercept</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="kamelet-eip.html">Kamelet</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="loadBalance-eip.html">Load Balance</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="log-eip.html">Log</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="loop-eip.html">Loop</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="marshal-eip.html">Marshal</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="message.html">Message</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="message-broker.html">Message Broker</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="message-bus.html">Message Bus</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="message-channel.html">Message Channel</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="message-dispatcher.html">Message Dispatcher</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="message-endpoint.html">Message Endpoint</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="message-expiration.html">Message Expiration</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="message-history.html">Message History</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="message-router.html">Message Router</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="message-translator.html">Message Translator</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="messaging-bridge.html">Messaging Bridge</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="messaging-gateway.html">Messaging Gateway</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="messaging-mapper.html">Messaging Mapper</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="multicast-eip.html">Multicast</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="normalizer.html">Normalizer</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="pipeline-eip.html">Pipeline</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="point-to-point-channel.html">Point to Point Channel</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="pollEnrich-eip.html">Poll Enrich</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="polling-consumer.html">Polling Consumer</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="process-eip.html">Process</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="process-manager.html">Process Manager</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="publish-subscribe-channel.html">Publish Subscribe Channel</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="recipientList-eip.html">Recipient List</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="removeHeader-eip.html">Remove Header</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="removeHeaders-eip.html">Remove Headers</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="removeProperties-eip.html">Remove Properties</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="removeProperty-eip.html">Remove Property</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="requestReply-eip.html">Request Reply</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="resequence-eip.html">Resequence</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="resilience4j-eip.html">Resilience4j Circuit Breaker</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="return-address.html">Return Address</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="rollback-eip.html">Rollback</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="routingSlip-eip.html">Routing Slip</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="saga-eip.html">Saga</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="sample-eip.html">Sample</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="scatter-gather.html">Scatter Gather</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="script-eip.html">Script</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="selective-consumer.html">Selective Consumer</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="service-activator.html">Service Activator</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="serviceCall-eip.html">Service Call</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="setBody-eip.html">Set Body</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="setHeader-eip.html">Set Header</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="setProperty-eip.html">Set Property</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="sort-eip.html">Sort</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="split-eip.html">Split</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="step-eip.html">Step</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="stop-eip.html">Stop</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="threads-eip.html">Threads</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="throttle-eip.html">Throttle</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="to-eip.html">To</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="toD-eip.html">To Dynamic</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="transactional-client.html">Transactional Client</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="transform-eip.html">Transform</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="unmarshal-eip.html">Unmarshal</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="validate-eip.html">Validate</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="wireTap-eip.html">Wire Tap</a>
  </li>
</ul>
  </li>
</ul>
  </li>
</ul>
  </nav>
</div>
<div class="nav-panel-explore" data-panel="explore">
  <div class="context">
    <span class="title">Camel Components</span>
    <span class="version">4.0.x</span>
  </div>
  <ul class="components">
    <li class="component is-current">
      <div class="title"><a href="../../4.10.x/index.html">Camel Components</a></div>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../4.10.x/index.html">4.10.x (LTS)</a>
        </li>
        <li class="version">
          <a href="../../4.8.x/index.html">4.8.x</a>
        </li>
        <li class="version">
          <a href="../../4.4.x/index.html">4.4.x</a>
        </li>
        <li class="version is-current">
          <a href="../index.html">4.0.x</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <div class="title"><a href="../../../manual/4.10.x/index.html">User manual</a></div>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../../manual/4.10.x/index.html">4.10.x</a>
        </li>
        <li class="version">
          <a href="../../../manual/4.8.x/index.html">4.8.x</a>
        </li>
        <li class="version">
          <a href="../../../manual/4.4.x/index.html">4.4.x</a>
        </li>
        <li class="version">
          <a href="../../../manual/4.0.x/index.html">4.0.x</a>
        </li>
      </ul>
    </li>
  </ul>
</div>
    </div>
  </aside>
</div>
<main class="article">
<div class="toolbar" role="navigation">
<button class="nav-toggle"></button>
  <a href="../../../manual/4.10.x/index.html" class="home-link"></a>
<nav class="breadcrumbs" aria-label="breadcrumbs">
  <ul>
    <li><a href="../index.html">Camel Components</a></li>
    <li><a href="enterprise-integration-patterns.html">Enterprise Integration Patterns</a></li>
    <li><a href="aggregate-eip.html">Aggregate</a></li>
  </ul>
</nav>
<div class="page-versions">
  <button class="version-menu-toggle" title="Show other versions of page">4.0.x</button>
  <div class="version-menu">
    <a class="version" href="../../4.10.x/eips/aggregate-eip.html">4.10.x (LTS)</a>
    <a class="version" href="../../4.8.x/eips/aggregate-eip.html">4.8.x</a>
    <a class="version" href="../../4.4.x/eips/aggregate-eip.html">4.4.x</a>
    <a class="version is-current" href="aggregate-eip.html">4.0.x</a>
  </div>
</div>

</div>
  <div class="content">
<aside class="toc sidebar" data-title="Contents" data-levels="2">
  <div class="toc-menu"></div>
</aside>
<article class="doc">
<h1 class="page">Aggregate</h1>
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>The
<a href="http://www.enterpriseintegrationpatterns.com/Aggregator.html">Aggregator</a>
from the <a href="enterprise-integration-patterns.html" class="xref page">EIP patterns</a> allows
you to combine a number of messages together into a single message.</p>
</div>
<div class="paragraph">
<p>How do we combine the results of individual, but related messages so that they can be processed as a whole?</p>
</div>
<div class="imageblock">
<div class="content">
<img src="_images/eip/Aggregator.gif" alt="image">
</div>
</div>
<div class="paragraph">
<p>Use a stateful filter, an Aggregator, to collect and store individual messages until a complete set of related messages has been received. Then, the Aggregator publishes a single message distilled from the individual messages.</p>
</div>
<div class="paragraph">
<p>The aggregator is one of the most complex EIP and has many features and configurations.</p>
</div>
<div class="paragraph">
<p>The logic for combing messages together is <em>correlated</em> in buckets based on a <em>correlation key</em>.
Messages with the same correlation key is aggregated together, using an <code>AggregationStrategy</code>.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_aggregate_options"><a class="anchor" href="#_aggregate_options"></a>Aggregate options</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The Aggregate eip supports 28 options, which are listed below.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 20%;">
<col style="width: 50%;">
<col style="width: 10%;">
<col style="width: 20%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Name</th>
<th class="tableblock halign-left valign-top">Description</th>
<th class="tableblock halign-center valign-top">Default</th>
<th class="tableblock halign-left valign-top">Type</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong id="_option_correlationExpression">correlationExpression</strong></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><strong>Required</strong> The expression used to calculate the correlation key to use for aggregation. The Exchange which has the same correlation key is aggregated together. If the correlation key could not be evaluated an Exception is thrown. You can disable this by using the ignoreBadCorrelationKeys option.</p>
</div></div></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ExpressionSubElementDefinition</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong id="_option_completionPredicate">completionPredicate</strong></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>A Predicate to indicate when an aggregated exchange is complete. If this is not specified and the AggregationStrategy object implements Predicate, the aggregationStrategy object will be used as the completionPredicate.</p>
</div></div></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ExpressionSubElementDefinition</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong id="_option_completionTimeoutExpression">completionTimeoutExpression</strong></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Time in millis that an aggregated exchange should be inactive before its complete (timeout). This option can be set as either a fixed value or using an Expression which allows you to evaluate a timeout dynamically - will use Long as result. If both are set Camel will fallback to use the fixed value if the Expression result was null or 0. You cannot use this option together with completionInterval, only one of the two can be used. By default the timeout checker runs every second, you can use the completionTimeoutCheckerInterval option to configure how frequently to run the checker. The timeout is an approximation and there is no guarantee that the a timeout is triggered exactly after the timeout value. It is not recommended to use very low timeout values or checker intervals.</p>
</div></div></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ExpressionSubElementDefinition</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong id="_option_completionSizeExpression">completionSizeExpression</strong></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Number of messages aggregated before the aggregation is complete. This option can be set as either a fixed value or using an Expression which allows you to evaluate a size dynamically - will use Integer as result. If both are set Camel will fallback to use the fixed value if the Expression result was null or 0.</p>
</div></div></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ExpressionSubElementDefinition</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong id="_option_optimisticLockRetryPolicy">optimisticLockRetryPolicy</strong></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Allows to configure retry settings when using optimistic locking.</p>
</div></div></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">OptimisticLockRetryPolicyDefinition</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong id="_option_parallelProcessing">parallelProcessing</strong></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>When aggregated are completed they are being send out of the aggregator. This option indicates whether or not Camel should use a thread pool with multiple threads for concurrency. If no custom thread pool has been specified then Camel creates a default pool with 10 concurrent threads.</p>
</div></div></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">false</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Boolean</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong id="_option_optimisticLocking">optimisticLocking</strong></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Turns on using optimistic locking, which requires the aggregationRepository being used, is supporting this by implementing org.apache.camel.spi.OptimisticLockingAggregationRepository .</p>
</div></div></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">false</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Boolean</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong id="_option_executorService">executorService</strong></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>If using parallelProcessing you can specify a custom thread pool to be used. In fact also if you are not using parallelProcessing this custom thread pool is used to send out aggregated exchanges as well.</p>
</div></div></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ExecutorService</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong id="_option_timeoutCheckerExecutorService">timeoutCheckerExecutorService</strong></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>If using either of the completionTimeout, completionTimeoutExpression, or completionInterval options a background thread is created to check for the completion for every aggregator. Set this option to provide a custom thread pool to be used rather than creating a new thread for every aggregator.</p>
</div></div></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ScheduledExecutorService</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong id="_option_aggregateController">aggregateController</strong></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>To use a org.apache.camel.processor.aggregate.AggregateController to allow external sources to control this aggregator.</p>
</div></div></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">AggregateController</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong id="_option_aggregationRepository">aggregationRepository</strong></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>The AggregationRepository to use. Sets the custom aggregate repository to use. Will by default use org.apache.camel.processor.aggregate.MemoryAggregationRepository.</p>
</div></div></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">AggregationRepository</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong id="_option_aggregationStrategy">aggregationStrategy</strong></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>The AggregationStrategy to use. For example to lookup a bean with the name foo, the value is simply just #bean:foo. Configuring an AggregationStrategy is required, and is used to merge the incoming Exchange with the existing already merged exchanges. At first call the oldExchange parameter is null. On subsequent invocations the oldExchange contains the merged exchanges and newExchange is of course the new incoming Exchange.</p>
</div></div></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">AggregationStrategy</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong id="_option_aggregationStrategyMethodName">aggregationStrategyMethodName</strong></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>This option can be used to explicit declare the method name to use, when using beans as the AggregationStrategy.</p>
</div></div></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">String</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong id="_option_aggregationStrategyMethodAllowNull">aggregationStrategyMethodAllowNull</strong></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>If this option is false then the aggregate method is not used for the very first aggregation. If this option is true then null values is used as the oldExchange (at the very first aggregation), when using beans as the AggregationStrategy.</p>
</div></div></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">false</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Boolean</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong id="_option_completionSize">completionSize</strong></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Number of messages aggregated before the aggregation is complete. This option can be set as either a fixed value or using an Expression which allows you to evaluate a size dynamically - will use Integer as result. If both are set Camel will fallback to use the fixed value if the Expression result was null or 0.</p>
</div></div></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Integer</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong id="_option_completionInterval">completionInterval</strong></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>A repeating period in millis by which the aggregator will complete all current aggregated exchanges. Camel has a background task which is triggered every period. You cannot use this option together with completionTimeout, only one of them can be used.</p>
</div></div></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">String</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong id="_option_completionTimeout">completionTimeout</strong></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Time in millis that an aggregated exchange should be inactive before its complete (timeout). This option can be set as either a fixed value or using an Expression which allows you to evaluate a timeout dynamically - will use Long as result. If both are set Camel will fallback to use the fixed value if the Expression result was null or 0. You cannot use this option together with completionInterval, only one of the two can be used. By default the timeout checker runs every second, you can use the completionTimeoutCheckerInterval option to configure how frequently to run the checker. The timeout is an approximation and there is no guarantee that the a timeout is triggered exactly after the timeout value. It is not recommended to use very low timeout values or checker intervals.</p>
</div></div></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">String</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong id="_option_completionTimeoutCheckerInterval">completionTimeoutCheckerInterval</strong></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Interval in millis that is used by the background task that checks for timeouts ( org.apache.camel.TimeoutMap ). By default the timeout checker runs every second. The timeout is an approximation and there is no guarantee that the a timeout is triggered exactly after the timeout value. It is not recommended to use very low timeout values or checker intervals.</p>
</div></div></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1000</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">String</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong id="_option_completionFromBatchConsumer">completionFromBatchConsumer</strong></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Enables the batch completion mode where we aggregate from a org.apache.camel.BatchConsumer and aggregate the total number of exchanges the org.apache.camel.BatchConsumer has reported as total by checking the exchange property org.apache.camel.Exchange#BATCH_COMPLETE when its complete. This option cannot be used together with discardOnAggregationFailure.</p>
</div></div></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">false</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Boolean</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong id="_option_completionOnNewCorrelationGroup">completionOnNewCorrelationGroup</strong></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Enables completion on all previous groups when a new incoming correlation group. This can for example be used to complete groups with same correlation keys when they are in consecutive order. Notice when this is enabled then only 1 correlation group can be in progress as when a new correlation group starts, then the previous groups is forced completed.</p>
</div></div></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">false</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Boolean</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong id="_option_eagerCheckCompletion">eagerCheckCompletion</strong></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Use eager completion checking which means that the completionPredicate will use the incoming Exchange. As opposed to without eager completion checking the completionPredicate will use the aggregated Exchange.</p>
</div></div></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">false</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Boolean</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong id="_option_ignoreInvalidCorrelationKeys">ignoreInvalidCorrelationKeys</strong></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>If a correlation key cannot be successfully evaluated it will be ignored by logging a DEBUG and then just ignore the incoming Exchange.</p>
</div></div></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">false</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Boolean</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong id="_option_closeCorrelationKeyOnCompletion">closeCorrelationKeyOnCompletion</strong></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Closes a correlation key when its complete. Any late received exchanges which has a correlation key that has been closed, it will be defined and a ClosedCorrelationKeyException is thrown.</p>
</div></div></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Integer</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong id="_option_discardOnCompletionTimeout">discardOnCompletionTimeout</strong></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Discards the aggregated message on completion timeout. This means on timeout the aggregated message is dropped and not sent out of the aggregator.</p>
</div></div></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">false</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Boolean</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong id="_option_discardOnAggregationFailure">discardOnAggregationFailure</strong></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Discards the aggregated message when aggregation failed (an exception was thrown from AggregationStrategy . This means the partly aggregated message is dropped and not sent out of the aggregator. This option cannot be used together with completionFromBatchConsumer.</p>
</div></div></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">false</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Boolean</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong id="_option_forceCompletionOnStop">forceCompletionOnStop</strong></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Indicates to complete all current aggregated exchanges when the context is stopped.</p>
</div></div></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">false</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Boolean</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong id="_option_completeAllOnStop">completeAllOnStop</strong></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Indicates to wait to complete all current and partial (pending) aggregated exchanges when the context is stopped. This also means that we will wait for all pending exchanges which are stored in the aggregation repository to complete so the repository is empty before we can stop. You may want to enable this when using the memory based aggregation repository that is memory based only, and do not store data on disk. When this option is enabled, then the aggregator is waiting to complete all those exchanges before its stopped, when stopping CamelContext or the route using it.</p>
</div></div></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">false</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Boolean</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong id="_option_outputs">outputs</strong></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><strong>Required</strong></p>
</div></div></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">List</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong id="_option_disabled">disabled</strong></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Whether to disable this EIP from the route during build time. Once an EIP has been disabled then it cannot be enabled later at runtime.</p>
</div></div></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">false</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Boolean</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong id="_option_description">description</strong></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Sets the description of this node.</p>
</div></div></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">DescriptionDefinition</p></td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="sect1">
<h2 id="_worker_pools"><a class="anchor" href="#_worker_pools"></a>Worker pools</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The aggregate EIP will always use a worker pool, that is used to process all the outgoing messages from the aggregator.
The worker pool is determined accordingly:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>If a custom <code>ExecutorService</code> has been configured, then this is used as worker pool.</p>
</li>
<li>
<p>If <code>parallelProcessing=true</code> then a <em>default</em> worker pool (is 10 worker threads by default) is created.
However, the thread pool size and other configurations can be configured using <em>thread pool profiles</em>.</p>
</li>
<li>
<p>Otherwise, a single threaded worker pool is created.</p>
</li>
<li>
<p>In order to achieve synchronous aggregation, use an instance of <code>SynchronousExecutorService</code> for the
<code>executorService</code> option. The aggregated output will execute in the same thread that called the aggregator.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_aggregating"><a class="anchor" href="#_aggregating"></a>Aggregating</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The <code>AggregationStrategy</code> is used for aggregating the old, and the new exchanges together into a single exchange;
that becomes the next old, when the next message is aggregated, and so forth.</p>
</div>
<div class="paragraph">
<p>Possible implementations include performing some kind of combining or
delta processing, such as adding line items together into an invoice or
just using the newest exchange and removing old exchanges such as for
state tracking or market data prices; where old values are of little
use.</p>
</div>
<div class="paragraph">
<p>Notice the aggregation strategy is a mandatory option and must be
provided to the aggregator.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
In the aggregate method, do not create a new exchange instance to return,
instead return either the old or new exchange from the input parameters;
favor returning the old exchange whenever possible.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Here are a few example <code>AggregationStrategy</code> implementations that should
help you create your own custom strategy.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">//simply combines Exchange String body values using '+' as a delimiter
class StringAggregationStrategy implements AggregationStrategy {

    public Exchange aggregate(Exchange oldExchange, Exchange newExchange) {
        if (oldExchange == null) {
            return newExchange;
        }

        String oldBody = oldExchange.getIn().getBody(String.class);
        String newBody = newExchange.getIn().getBody(String.class);
        oldExchange.getIn().setBody(oldBody + "+" + newBody);
        return oldExchange;
    }
}

//simply combines Exchange body values into an ArrayList&lt;Object&gt;
class ArrayListAggregationStrategy implements AggregationStrategy {

    public Exchange aggregate(Exchange oldExchange, Exchange newExchange) {
        Object newBody = newExchange.getIn().getBody();
        ArrayList&lt;Object&gt; list = null;
        if (oldExchange == null) {
            list = new ArrayList&lt;Object&gt;();
            list.add(newBody);
            newExchange.getIn().setBody(list);
            return newExchange;
        } else {
            list = oldExchange.getIn().getBody(ArrayList.class);
            list.add(newBody);
            return oldExchange;
        }
    }
}</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
The <code>org.apache.camel.builder.AggregationStrategies</code> is a builder that can
be used for creating commonly used aggregation strategies without having to create a class.
</td>
</tr>
</table>
</div>
<div class="sect2">
<h3 id="_exchange_properties"><a class="anchor" href="#_exchange_properties"></a>Exchange Properties</h3>
<div class="paragraph">
<p>The completed (outgoing) exchange from the Aggregate EIP contains the following information
as exchange properties, allowing you to know how the exchange was completed, and how
many messages were combined.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 30%;">
<col style="width: 10%;">
<col style="width: 60%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Property</th>
<th class="tableblock halign-left valign-top">Type</th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>CamelAggregatedSize</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code><code>int</code></code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The total number of messages aggregated.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>CamelAggregatedCompletedBy</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code><code>String</code></code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The condition that triggered the completion. Possible values are size, timeout, interval, predicate, force, strategy, and consumer. The consumer value represents the completion from batch consumer.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>CamelAggregatedCorrelationKey</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code><code>String</code></code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The correlation identifier as a <code>String</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>CamelAggregatedTimeout</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code><code>long</code></code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The time-out in milliseconds as set by the completion time-out.</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect2">
<h3 id="_aggregate_by_grouping_exchanges"><a class="anchor" href="#_aggregate_by_grouping_exchanges"></a>Aggregate by grouping exchanges</h3>
<div class="paragraph">
<p>In the route below we group all the exchanges together using
<code>GroupedExchangeAggregationStrategy</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">from("direct:start")
    // aggregate all using same expression and group the
    // exchanges so we get one single exchange containing all
    // the others
    .aggregate(new GroupedExchangeAggregationStrategy()).constant(true)
    // wait for 0.5 seconds to aggregate
    .completionTimeout(500L).to("mock:result");</code></pre>
</div>
</div>
<div class="paragraph">
<p>As a result we have one outgoing <code>Exchange</code> being
routed to the <code>"mock:result"</code> endpoint. The exchange is a holder
containing all the incoming Exchanges.</p>
</div>
<div class="paragraph">
<p>The output of the aggregator will then contain the exchanges grouped
together in a list as shown below:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">List&lt;Exchange&gt; grouped = exchange.getMessage().getBody(List.class);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_aggregating_into_a_list"><a class="anchor" href="#_aggregating_into_a_list"></a>Aggregating into a List</h3>
<div class="paragraph">
<p>If you want to aggregate some value from the messages <code>&lt;V&gt;</code> into a <code>List&lt;V&gt;</code>
then you can use the
<code>org.apache.camel.processor.aggregate.AbstractListAggregationStrategy</code>
abstract class.</p>
</div>
<div class="paragraph">
<p>The completed Exchange that is sent out of the aggregator will contain the <code>List&lt;V&gt;</code> in
the message body.</p>
</div>
<div class="paragraph">
<p>For example to aggregate a <code>List&lt;Integer&gt;</code> you can extend this class as
shown below, and implement the <code>getValue</code> method:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class MyListOfNumbersStrategy extends AbstractListAggregationStrategy&lt;Integer&gt; {

    @Override
    public Integer getValue(Exchange exchange) {
        // the message body contains a number, so just return that as-is
        return exchange.getIn().getBody(Integer.class);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>org.apache.camel.builder.AggregationStrategies</code> is a builder that can
be used for creating commonly used aggregation strategies without having to create a class.</p>
</div>
<div class="paragraph">
<p>The previous example can also be built using the builder as shown:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">AggregationStrategy agg = AggregationStrategies.flexible(Integer.class)
    .accumulateInCollection(ArrayList.class)
    .pick(body());</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_aggregating_on_timeout"><a class="anchor" href="#_aggregating_on_timeout"></a>Aggregating on timeout</h3>
<div class="paragraph">
<p>If your aggregation strategy implements
<code>TimeoutAwareAggregationStrategy</code>, then Camel will invoke the <code>timeout</code>
method when the timeout occurs. Notice that the values for index and
total parameters will be -1, and the timeout parameter will be provided
only if configured as a fixed value. You must <strong>not</strong> throw any exceptions
from the <code>timeout</code> method.</p>
</div>
</div>
<div class="sect2">
<h3 id="_aggregate_with_persistent_repository"><a class="anchor" href="#_aggregate_with_persistent_repository"></a>Aggregate with persistent repository</h3>
<div class="paragraph">
<p>The aggregator provides a pluggable repository which you can implement
your own <code>org.apache.camel.spi.AggregationRepository</code>.</p>
</div>
<div class="paragraph">
<p>If you need persistent repository then Camel provides numerous implementations, such as from the
<a href="#ROOT:caffeine-cache-component.adoc" class="xref unresolved">Caffeine</a>,
<a href="#ROOT:cql-component.adoc" class="xref unresolved">CassandraQL</a>,
<a href="#ROOT:ehcache-component.adoc" class="xref unresolved">EHCache</a>,
<a href="#ROOT:infinispan-component.adoc" class="xref unresolved">Infinispan</a>,
<a href="#ROOT:jcache-component.adoc" class="xref unresolved">JCache</a>,
<a href="#others:leveldb.adoc" class="xref unresolved">LevelDB</a>,
<a href="#others:redis.adoc" class="xref unresolved">Redis</a>,
or <a href="#ROOT:sql-component.adoc" class="xref unresolved">SQL</a> components.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_completion"><a class="anchor" href="#_completion"></a>Completion</h2>
<div class="sectionbody">
<div class="paragraph">
<p>When aggregation <a href="../../../manual/4.10.x/exchange.html" class="xref page">Exchange</a>s at some point you need to
indicate that the aggregated exchanges is complete, so they can be sent
out of the aggregator. Camel allows you to indicate completion in
various ways as follows:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><em>completionTimeout</em> - Is an inactivity timeout in which is triggered if
no new exchanges have been aggregated for that particular correlation
key within the period.</p>
</li>
<li>
<p><em>completionInterval</em> - Once every X period all the current aggregated
exchanges are completed.</p>
</li>
<li>
<p><em>completionSize</em> - Is a number indicating that after X aggregated
exchanges its complete.</p>
</li>
<li>
<p><em>completionPredicate</em> - Runs a <a href="../../../manual/4.10.x/predicate.html" class="xref page">Predicate</a> when a new
exchange is aggregated to determine if we are complete or not.
The configured aggregationStrategy can implement the
Predicate interface and will be used as the completionPredicate if no
completionPredicate is configured. The configured aggregationStrategy can
override the <code>preComplete</code> method and will be used as
the completionPredicate in pre-complete check mode. See further below
for more details.</p>
</li>
<li>
<p><em>completionFromBatchConsumer</em> - Special option for
<a href="../../../manual/4.10.x/batch-consumer.html" class="xref page">Batch Consumer</a> which allows you to complete
when all the messages from the batch has been aggregated.</p>
</li>
<li>
<p><em>forceCompletionOnStop</em> - Indicates to complete all current
aggregated exchanges when the context is stopped</p>
</li>
<li>
<p><em>AggregateController</em> - which allows to use an external source (<code>AggregateController</code> implementation) to complete groups or all groups.
This can be done using Java or JMX API.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>All the different completions are per correlation key. You can
combine them in any way you like. It&#8217;s basically the first which
triggers that wins. So you can use a completion size together with a
completion timeout. Only completionTimeout and completionInterval cannot
be used at the same time.</p>
</div>
<div class="paragraph">
<p>Completion is mandatory and must be configured on the aggregation.</p>
</div>
<div class="sect2">
<h3 id="_pre_completion_mode"><a class="anchor" href="#_pre_completion_mode"></a>Pre-completion mode</h3>
<div class="paragraph">
<p>There can be use-cases where you want the incoming
<a href="../../../manual/4.10.x/exchange.html" class="xref page">Exchange</a> to determine if the correlation group
should pre-complete, and then the incoming
<a href="../../../manual/4.10.x/exchange.html" class="xref page">Exchange</a> is starting a new group from scratch.
The pre-completion mode must be enabled by the <code>AggregationStrategy</code> by overriding the <code>canPreComplete</code> method
to return a <code>true</code> value.</p>
</div>
<div class="paragraph">
<p>When pre completion is enabled then the <code>preComplete</code> method is invoked:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">/**
 * Determines if the aggregation should complete the current group, and start a new group, or the aggregation
 * should continue using the current group.
 *
 * @param oldExchange the oldest exchange (is &lt;tt&gt;null&lt;/tt&gt; on first aggregation as we only have the new exchange)
 * @param newExchange the newest exchange (can be &lt;tt&gt;null&lt;/tt&gt; if there was no data possible to acquire)
 * @return &lt;tt&gt;true&lt;/tt&gt; to complete current group and start a new group, or &lt;tt&gt;false&lt;/tt&gt; to keep using current
 */
boolean preComplete(Exchange oldExchange, Exchange newExchange);</code></pre>
</div>
</div>
<div class="paragraph">
<p>If the <code>preComplete</code> method returns <code>true</code>, then the existing correlation groups is
completed (without aggregating the incoming exchange (<code>newExchange</code>).
Then the <code>newExchange</code> is used to start the correlation group from scratch,
so the group would contain only that new incoming exchange. This is
known as pre-completion mode.</p>
</div>
<div class="paragraph">
<p>The <code>newExchange</code> contains the following exchange properties, which can be used
to determine whether to pre complete.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 30%;">
<col style="width: 10%;">
<col style="width: 60%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Property</th>
<th class="tableblock halign-left valign-top">Type</th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>CamelAggregatedSize</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code><code>int</code></code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The total number of messages aggregated.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>CamelAggregatedCorrelationKey</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code><code>String</code></code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The correlation identifier as a <code>String</code>.</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>When the aggregation is in <em>pre-completion</em> mode, then only the following completions are in use:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><em>completionTimeout</em> or <em>completionInterval</em> can also be used as fallback
completions</p>
</li>
<li>
<p>any other completion are not used (such as by size, from batch consumer etc)</p>
</li>
<li>
<p><em>eagerCheckCompletion</em> is implied as <code>true</code>, but the option has no effect</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_completionawareaggregationstrategy"><a class="anchor" href="#_completionawareaggregationstrategy"></a>CompletionAwareAggregationStrategy</h3>
<div class="paragraph">
<p>If your aggregation strategy implements
<code>CompletionAwareAggregationStrategy</code>, then Camel will invoke the
<code>onComplete</code> method when the aggregated <code>Exchange</code> is completed. This
allows you to do any last minute custom logic such as to clean up some
resources, or additional work on the exchange as it&#8217;s now completed.
You must <strong>not</strong> throw any exceptions from the <code>onCompletion</code> method.</p>
</div>
</div>
<div class="sect2">
<h3 id="_completing_current_group_decided_from_the_aggregationstrategy"><a class="anchor" href="#_completing_current_group_decided_from_the_aggregationstrategy"></a>Completing current group decided from the AggregationStrategy</h3>
<div class="paragraph">
<p>The <code>AggregationStrategy</code> supports checking for the</p>
</div>
<div class="paragraph">
<p>the exchange property (<code>Exchange.AGGREGATION_COMPLETE_CURRENT_GROUP</code>)
on the returned <code>Exchange</code> that contains a boolean to indicate if the current
group should be completed. This allows to overrule any existing
completion predicates / sizes / timeouts etc, and complete the group.</p>
</div>
<div class="paragraph">
<p>For example the following logic will complete the
group if the message body size is larger than 5. This is done by setting
the exchange property <code>Exchange.AGGREGATION_COMPLETE_CURRENT_GROUP</code> to <code>true</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public final class MyCompletionStrategy implements AggregationStrategy {
    @Override
    public Exchange aggregate(Exchange oldExchange, Exchange newExchange) {
        if (oldExchange == null) {
            return newExchange;
        }
        String body = oldExchange.getIn().getBody(String.class) + "+"
            + newExchange.getIn().getBody(String.class);
        oldExchange.getIn().setBody(body);
        if (body.length() &gt;= 5) {
            oldExchange.setProperty(Exchange.AGGREGATION_COMPLETE_CURRENT_GROUP, true);
        }
        return oldExchange;
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_completing_all_previous_group_decided_from_the_aggregationstrategy"><a class="anchor" href="#_completing_all_previous_group_decided_from_the_aggregationstrategy"></a>Completing all previous group decided from the AggregationStrategy</h3>
<div class="paragraph">
<p>The <code>AggregationStrategy</code> checks an exchange property, from the returned exchange,
indicating if all previous groups should be completed.</p>
</div>
<div class="paragraph">
<p>This allows to overrule any existing
completion predicates / sizes / timeouts etc, and complete all the existing
previous group.</p>
</div>
<div class="paragraph">
<p>The following logic will complete all the
previous groups, and start a new aggregation group.</p>
</div>
<div class="paragraph">
<p>This is done by setting the property <code>Exchange.AGGREGATION_COMPLETE_ALL_GROUPS</code> to <code>true</code>
on the returned exchange.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public final class MyCompletionStrategy implements AggregationStrategy {
    @Override
    public Exchange aggregate(Exchange oldExchange, Exchange newExchange) {
        if (oldExchange == null) {
            // we start a new correlation group, so complete all previous groups
            newExchange.setProperty(Exchange.AGGREGATION_COMPLETE_ALL_GROUPS, true);
            return newExchange;
        }

        String body1 = oldExchange.getIn().getBody(String.class);
        String body2 = newExchange.getIn().getBody(String.class);

        oldExchange.getIn().setBody(body1 + body2);
        return oldExchange;
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_manually_force_the_completion_of_all_aggregated_exchanges_immediately"><a class="anchor" href="#_manually_force_the_completion_of_all_aggregated_exchanges_immediately"></a>Manually force the completion of all aggregated Exchanges immediately</h3>
<div class="paragraph">
<p>You can manually trigger completion of all current aggregated exchanges
by sending an exchange containing the exchange property
<code>Exchange.AGGREGATION_COMPLETE_ALL_GROUPS</code> set to <code>true</code>. The message is
considered a signal message only, the message headers/contents will not
be processed otherwise.</p>
</div>
<div class="paragraph">
<p>You can alternatively set the exchange property
<code>Exchange.AGGREGATION_COMPLETE_ALL_GROUPS_INCLUSIVE</code> to <code>true</code> to trigger
completion of all groups after processing the current message.</p>
</div>
</div>
<div class="sect2">
<h3 id="_using_a_controller_to_force_the_aggregator_to_complete"><a class="anchor" href="#_using_a_controller_to_force_the_aggregator_to_complete"></a>Using a controller to force the aggregator to complete</h3>
<div class="paragraph">
<p>The <code>org.apache.camel.processor.aggregate.AggregateController</code> allows
you to control the aggregate at runtime using Java or JMX API. This can
be used to force completing groups of exchanges, or query its current
runtime statistics.</p>
</div>
<div class="paragraph">
<p>The aggregator provides a default implementation if no custom have been
configured, which can be accessed using <code>getAggregateController()</code> method.
Though it may be easier to configure a controller in the route using
<code>aggregateController</code> as shown below:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">private AggregateController controller = new DefaultAggregateController();

from("direct:start")
   .aggregate(header("id"), new MyAggregationStrategy())
      .completionSize(10).id("myAggregator")
      .aggregateController(controller)
      .to("mock:aggregated");</code></pre>
</div>
</div>
<div class="paragraph">
<p>Then there is API on <code>AggregateController</code> to force completion. For
example to complete a group with key foo:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">int groups = controller.forceCompletionOfGroup("foo");</code></pre>
</div>
</div>
<div class="paragraph">
<p>The returned value is the number of groups completed.
A value of 1 is returned if the foo group existed, otherwise 0 is returned.</p>
</div>
<div class="paragraph">
<p>There is also a method to complete all groups:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">int groups = controller.forceCompletionOfAllGroups();</code></pre>
</div>
</div>
<div class="paragraph">
<p>The controller can also be used in XML DSL using the <code>aggregateController</code> to
refer to a bean with the controller implementation, which is looked up in the registry.</p>
</div>
<div class="paragraph">
<p>When using Spring XML you can create the bean with <code>&lt;bean&gt;</code> as shown:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;bean id="myController" class="org.apache.camel.processor.aggregate.DefaultAggregateController"/&gt;

&lt;camelContext xmlns="http://camel.apache.org/schema/spring"&gt;
    &lt;route&gt;
        &lt;from uri="direct:start"/&gt;
        &lt;aggregate aggregationStrategy="myAppender" completionSize="10"
                   aggregateController="myController"&gt;
            &lt;correlationExpression&gt;
                &lt;header&gt;id&lt;/header&gt;
            &lt;/correlationExpression&gt;
            &lt;to uri="mock:result"/&gt;
        &lt;/aggregate&gt;
    &lt;/route&gt;
&lt;/camelContext&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>There is also JMX API on the aggregator which is available under the processors node in the Camel JMX tree.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_aggregating_with_beans"><a class="anchor" href="#_aggregating_with_beans"></a>Aggregating with Beans</h2>
<div class="sectionbody">
<div class="paragraph">
<p>To use the <code>AggregationStrategy</code> you had to implement the
<code>org.apache.camel.AggregationStrategy</code> interface,
which means your logic would be tied to the Camel API.
You can use a bean for the logic and let Camel adapt to your
bean. To use a bean a convention must be followed:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>there must be a public method to use</p>
</li>
<li>
<p>the method must not be void</p>
</li>
<li>
<p>the method can be static or non-static</p>
</li>
<li>
<p>the method must have 2 or more parameters</p>
</li>
<li>
<p>the parameters are paired, so the first half is applied to the
<code>oldExchange</code>, and the reminder half is for the <code>newExchange</code>.
 Therefore, there must be an equal number of parameters, eg 2, 4, 6 etc.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The paired methods is expected to be ordered as follows:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>the first parameter is the message body</p>
</li>
<li>
<p>optional, the 2nd parameter is a <code>Map</code> of the headers</p>
</li>
<li>
<p>optional, the 3rd parameter is a <code>Map</code> of the exchange properties</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>This convention is best explained with some examples.</p>
</div>
<div class="paragraph">
<p>In the method below, we have only 2 parameters, so the 1st parameter is
the body of the <code>oldExchange</code>, and the 2nd is paired to the body of the
<code>newExchange</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public String append(String existing, String next) {
    return existing + next;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the method below, we have only 4 parameters, so the 1st parameter is
the body of the <code>oldExchange</code>, and the 2nd is the <code>Map</code> of the
<code>oldExchange</code> headers, and the 3rd is paired to the body of the <code>newExchange</code>,
and the 4th parameter is the <code>Map</code> of the <code>newExchange</code> headers:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public String append(String existing, Map existingHeaders, String next, Map nextHeaders) {
    return existing + next;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>And finally if we have 6 parameters, that includes the exchange properties:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public String append(String existing, Map existingHeaders, Map existingProperties,
                     String next, Map nextHeaders, Map nextProperties) {
    return existing + next;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>To use this with the aggregate EIP we can use a bean with the aggregate logic as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class MyBodyAppender {

    public String append(String existing, String next) {
        return next + existing;
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>And then in the Camel route we create an instance of our bean, and then
refer to the bean in the route using <code>bean</code> method from
<code>org.apache.camel.builder.AggregationStrategies</code> as shown:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">private MyBodyAppender appender = new MyBodyAppender();

public void configure() throws Exception {
    from("direct:start")
        .aggregate(constant(true), AggregationStrategies.bean(appender, "append"))
            .completionSize(3)
            .to("mock:result");
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>We can also provide the bean class type directly:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public void configure() throws Exception {
    from("direct:start")
        .aggregate(constant(true), AggregationStrategies.bean(MyBodyAppender.class, "append"))
            .completionSize(3)
            .to("mock:result");
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>And if the bean has only one method we do not need to specify the name
of the method:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public void configure() throws Exception {
    from("direct:start")
        .aggregate(constant(true), AggregationStrategies.bean(MyBodyAppender.class))
            .completionSize(3)
            .to("mock:result");
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>And the <code>append</code> method could be static:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class MyBodyAppender {

    public static String append(String existing, String next) {
        return next + existing;
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you are using XML DSL then we need to declare a <code>&lt;bean&gt;</code> with the bean:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;bean id="myAppender" class="com.foo.MyBodyAppender"/&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>And in the Camel route we use <code>aggregationStrategy</code> to refer to the bean by its
id, and the <code>strategyMethodName</code> can be used to define the method name
to call:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;camelContext xmlns="http://camel.apache.org/schema/spring"&gt;
    &lt;route&gt;
        &lt;from uri="direct:start"/&gt;
        &lt;aggregate aggregationStrategy="myAppender" aggregationStrategyMethodName="append" completionSize="3"&gt;
            &lt;correlationExpression&gt;
                &lt;constant&gt;true&lt;/constant&gt;
            &lt;/correlationExpression&gt;
            &lt;to uri="mock:result"/&gt;
        &lt;/aggregate&gt;
    &lt;/route&gt;
&lt;/camelContext&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>When using XML DSL you can also specify the bean class directly in <code>aggregationStrategy</code>
using the <code>#class:</code> syntax as shown:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;route&gt;
    &lt;from uri="direct:start"/&gt;
    &lt;aggregate aggregationStrategy="#class:com.foo.MyBodyAppender" aggregationStrategyMethodName="append" completionSize="3"&gt;
        &lt;correlationExpression&gt;
            &lt;constant&gt;true&lt;/constant&gt;
        &lt;/correlationExpression&gt;
        &lt;to uri="mock:result"/&gt;
    &lt;/aggregate&gt;
&lt;/route&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can use this in XML DSL when you are not using the classic Spring XML files;
where you use XML only for Camel routes.</p>
</div>
<div class="sect2">
<h3 id="_aggregating_when_no_data"><a class="anchor" href="#_aggregating_when_no_data"></a>Aggregating when no data</h3>
<div class="paragraph">
<p>When using bean as <code>AggregationStrategy</code>, then the method is
<strong>only</strong> invoked when there is data to be aggregated, meaning that the message body
is not <code>null</code>. In cases where you want to have the method invoked, even when there are no data (message body is <code>null</code>),
then set the <code>strategyMethodAllowNull</code> to <code>true</code>.</p>
</div>
<div class="paragraph">
<p>When using beans this can be configured a bit easier using the <code>beanAllowNull</code> method
from <code>AggregationStrategies</code> as shown:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public void configure() throws Exception {
    from("direct:start")
        .pollEnrich("seda:foo", 1000, AggregationStrategies.beanAllowNull(appender, "append"))
            .to("mock:result");
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Then the <code>append</code> method in the bean would need to deal with the
situation that <code>newExchange</code> can be <code>null</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class MyBodyAppender {

    public String append(String existing, String next) {
        if (next == null) {
            return "NewWasNull" + existing;
        } else {
            return existing + next;
        }
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the example above we use the <a href="content-enricher.html" class="xref page">Content Enricher</a>
EIP using <code>pollEnrich</code>. The <code>newExchange</code> will be <code>null</code> in the
situation we could not get any data from the "seda:foo" endpoint, and
a timeout was hit after 1 second.</p>
</div>
<div class="paragraph">
<p>So if we need to do special merge logic we would need to set <code>setAllowNullNewExchange=true</code>.
If we don&#8217;t do this then on timeout the append method would normally not be
invoked, meaning the <a href="content-enricher.html" class="xref page">Content Enricher</a> did
not merge/change the message.</p>
</div>
<div class="paragraph">
<p>In XML DSL you would configure the <code>strategyMethodAllowNull</code> option and
set it to <code>true</code> as shown below:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;camelContext xmlns="http://camel.apache.org/schema/spring"&gt;
    &lt;route&gt;
        &lt;from uri="direct:start"/&gt;
        &lt;aggregate aggregationStrategy="myAppender"
                   aggregationStrategyMethodName="append"
                   aggregationStrategyMethodAllowNull="true"
                   completionSize="3"&gt;
            &lt;correlationExpression&gt;
                &lt;constant&gt;true&lt;/constant&gt;
            &lt;/correlationExpression&gt;
            &lt;to uri="mock:result"/&gt;
        &lt;/aggregate&gt;
    &lt;/route&gt;
&lt;/camelContext&gt;</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_aggregating_with_different_body_types"><a class="anchor" href="#_aggregating_with_different_body_types"></a>Aggregating with different body types</h3>
<div class="paragraph">
<p>When for example using <code>strategyMethodAllowNull</code> as <code>true</code>, then the
parameter types of the message bodies does not have to be the same. For
example suppose we want to aggregate from a <code>com.foo.User</code> type to a
<code>List&lt;String&gt;</code> that contains the name of the user. We could code a bean as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public final class MyUserAppender {

    public List addUsers(List names, User user) {
        if (names == null) {
            names = new ArrayList();
        }
        names.add(user.getName());
        return names;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Notice that the return type is a <code>List</code> which we want to contain the name of the users.
The 1st parameter is the <code>List</code> of names, and the 2nd parameter is the incoming <code>com.foo.User</code> type.</p>
</div>
</div>
</div>
</div>
</article>
  </div>
</main>
</div>
<footer class="footer">
  <p>This page was built using the Antora default UI.</p>
  <p>The source code for this UI is licensed under the terms of the MPL-2.0 license.</p>
</footer>
<script id="site-script" src="../../../_/js/site.js" data-ui-root-path="../../../_"></script>
<script async src="../../../_/js/vendor/highlight.js"></script>
  </body>
</html>
